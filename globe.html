<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rotating Globe</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            width: 100%;
            height: 100%;
            background-color: transparent;
        }
        
        .globe-container {
            width: 100%;
            height: 100%;
            position: relative;
        }
        
        #globe-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
    </style>
    <!-- Import Three.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <div class="globe-container">
        <canvas id="globe-canvas"></canvas>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Set up scene
            const container = document.querySelector('.globe-container');
            const canvas = document.getElementById('globe-canvas');
            
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(45, container.offsetWidth / container.offsetHeight, 0.1, 1000);
            camera.position.z = 4.5;
            
            const renderer = new THREE.WebGLRenderer({ 
                canvas: canvas,
                antialias: true,
                alpha: true
            });
            renderer.setSize(container.offsetWidth, container.offsetHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            
            // Create globe
            const radius = 1.5;
            const segments = 64;
            
            // Create globe geometry
            const sphereGeometry = new THREE.SphereGeometry(radius, segments, segments);
            
            // Create wireframe material
            const wireframeMaterial = new THREE.MeshBasicMaterial({
                color: 0x000000,
                wireframe: true,
                transparent: true,
                opacity: 0.08
            });
            
            // Create globe mesh
            const globe = new THREE.Mesh(sphereGeometry, wireframeMaterial);
            scene.add(globe);
            
            // Create points geometry
            const pointsCount = 300;
            const pointsGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(pointsCount * 3);
            
            // Create points at random positions on the sphere
            for (let i = 0; i < pointsCount; i++) {
                const y = 1 - (i / (pointsCount - 1)) * 2;
                const radius = Math.sqrt(1 - y * y);
                
                const theta = Math.PI * (3 - Math.sqrt(5)) * i;
                
                const x = Math.cos(theta) * radius;
                const z = Math.sin(theta) * radius;
                
                positions[i * 3] = x * 1.5;
                positions[i * 3 + 1] = y * 1.5;
                positions[i * 3 + 2] = z * 1.5;
            }
            
            pointsGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            // Create material for points
            const pointsMaterial = new THREE.PointsMaterial({
                color: 0x000000,
                size: 0.02,
                transparent: true,
                opacity: 0.6
            });
            
            // Create points mesh
            const points = new THREE.Points(pointsGeometry, pointsMaterial);
            scene.add(points);
            
            // Create connections
            const linesMaterial = new THREE.LineBasicMaterial({
                color: 0x000000,
                transparent: true,
                opacity: 0.15
            });
            
            // Create cluster centers
            const clusterCount = 8;
            const clusterCenters = [];
            
            for (let i = 0; i < clusterCount; i++) {
                const phi = Math.acos(-1 + (2 * i) / clusterCount);
                const theta = Math.sqrt(clusterCount * Math.PI) * phi;
                
                clusterCenters.push({
                    x: radius * Math.sin(phi) * Math.cos(theta),
                    y: radius * Math.sin(phi) * Math.sin(theta),
                    z: radius * Math.cos(phi)
                });
            }
            
            // Create connections
            const connectionsCount = 120;
            const lines = [];
            
            for (let i = 0; i < connectionsCount; i++) {
                const clusterIndex = Math.floor(Math.random() * clusterCount);
                const center = clusterCenters[clusterIndex];
                
                let startIndex = 0;
                let endIndex = 0;
                let shortestDist1 = Infinity;
                let shortestDist2 = Infinity;
                
                for (let j = 0; j < pointsCount; j++) {
                    const x = positions[j * 3];
                    const y = positions[j * 3 + 1];
                    const z = positions[j * 3 + 2];
                    
                    const dist = Math.sqrt(
                        Math.pow(x - center.x, 2) + 
                        Math.pow(y - center.y, 2) + 
                        Math.pow(z - center.z, 2)
                    );
                    
                    if (dist < shortestDist1) {
                        shortestDist2 = shortestDist1;
                        endIndex = startIndex;
                        shortestDist1 = dist;
                        startIndex = j;
                    } else if (dist < shortestDist2) {
                        shortestDist2 = dist;
                        endIndex = j;
                    }
                }
                
                if (startIndex === endIndex) continue;
                
                const startPos = new THREE.Vector3(
                    positions[startIndex * 3],
                    positions[startIndex * 3 + 1],
                    positions[startIndex * 3 + 2]
                );
                
                const endPos = new THREE.Vector3(
                    positions[endIndex * 3],
                    positions[endIndex * 3 + 1],
                    positions[endIndex * 3 + 2]
                );
                
                const lineGeometry = new THREE.BufferGeometry().setFromPoints([startPos, endPos]);
                const line = new THREE.Line(lineGeometry, linesMaterial);
                scene.add(line);
                lines.push(line);
            }
            
            // Add ambient light
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            // Animation loop
            function animate() {
                requestAnimationFrame(animate);
                
                globe.rotation.y += 0.0005;
                points.rotation.y += 0.0005;
                
                lines.forEach(line => {
                    line.rotation.y += 0.0005;
                });
                
                renderer.render(scene, camera);
            }
            
            animate();
            
            // Handle window resize
            window.addEventListener('resize', function() {
                camera.aspect = container.offsetWidth / container.offsetHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.offsetWidth, container.offsetHeight);
            });
        });
    </script>
</body>
</html>
